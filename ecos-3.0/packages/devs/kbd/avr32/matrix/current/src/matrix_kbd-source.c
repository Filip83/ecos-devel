//==========================================================================
//
//      matrix_kbd.c
//
//      Keyboard driver for the AVR32UC3C-EK matrix button
//
//==========================================================================
// ####ECOSGPLCOPYRIGHTBEGIN####
// -------------------------------------------
// This file is part of eCos, the Embedded Configurable Operating System.
// Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
//
// eCos is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2 or (at your option) any later
// version.
//
// eCos is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License
// along with eCos; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//
// As a special exception, if other files instantiate templates or use
// macros or inline functions from this file, or you compile this file
// and link it with other works to produce a work based on this file,
// this file does not by itself cause the resulting work to be covered by
// the GNU General Public License. However the source code for this file
// must still be made available in accordance with section (3) of the GNU
// General Public License v2.
//
// This exception does not invalidate any other reasons why a work based
// on this file might be covered by the GNU General Public License.
// -------------------------------------------
// ####ECOSGPLCOPYRIGHTEND####
//==========================================================================
//#####DESCRIPTIONBEGIN####
//
// Author(s):    Filip Adamec
// Contributors:
// Date:         2012-11-15
// Purpose:
// Description:  Keyboardd driver for AVR32UC3C-EK matrix button
//
//####DESCRIPTIONEND####
//
//==========================================================================
#include <cyg/hal/gpio.h>
#include <cyg/hal/avr32/io.h>

#include <cyg/kernel/kapi.h>
#include <cyg/hal/hal_io.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/hal/drv_api.h>
#include <cyg/hal/hal_intr.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/infra/cyg_ass.h>
#include <cyg/infra/diag.h>

#include <cyg/io/devtab.h>
#include <st/devs/matrix_kbd.h>
#include <st/devs/linux_keyboard.h>
#include <st/DrvMsgQueue.h>
#include <st/window.h>

/** Matrix keyboard driver description.
*
* This driver use two sources of interrupt one from
* AST timer pir0 interrupt to generate keyboard scan
* intervals and external interrupt controller. The external
* interrupt controller interrupts are generated by keyboard
* input rows pins. As a response to this interrupt scanning
* timer is initialized. The external interrupt is enabled
* if no key is pressed. If the key is pressed the keyboard 
* is scanned periodically and key events is send in predefined
* periods to an application.  
*/

/** Declaration and initialization of matrix keyborad data structure.
*
*/
static cyg_kbd_avr32_t cyg_kbd_avr32 =
{
	.repeat_interval        = 5,
	.push_cnt				= 0,
    .last_scan_code         = 0,
	.scan_code				= 0,
    .scan_line              = 0,
    .is_open                = false,
	.enabled                = true,
    .kbd_interrupt          = NULL,
    .kbd_interrupt_handle   = NULL,
    .interrupt_number       = CYGNUM_HAL_VECTOR_AST_PER,
    .interrupt_prio         = CYGNUM_DEVS_KBD_MATRIX_INTERRUPT_PRIO,
	.kb_pins_isr[0].kbd_pin_interrupt			= NULL,
	.kb_pins_isr[0].kbd_pin_interrupt_handle	= NULL,
	.kb_pins_isr[0].kbd_pin_interrupt_number	= CYGNUM_HAL_VECTOR_EIC_1,
	
	.kb_pins_isr[1].kbd_pin_interrupt			= NULL,
	.kb_pins_isr[1].kbd_pin_interrupt_handle	= NULL,
	.kb_pins_isr[1].kbd_pin_interrupt_number	= CYGNUM_HAL_VECTOR_EIC_2,
	
	.kb_pins_isr[2].kbd_pin_interrupt			= NULL,
	.kb_pins_isr[2].kbd_pin_interrupt_handle	= NULL,
	.kb_pins_isr[2].kbd_pin_interrupt_number	= CYGNUM_HAL_VECTOR_EIC_3,
	
	.kb_pins_isr[3].kbd_pin_interrupt			= NULL,
	.kb_pins_isr[3].kbd_pin_interrupt_handle	= NULL,
	.kb_pins_isr[3].kbd_pin_interrupt_number	= CYGNUM_HAL_VECTOR_EIC_4,
};

static cyg_uint32
avr32_matrix_kbd_timer_ISR(cyg_vector_t vector, cyg_addrword_t data);

static void       
avr32_matrix_kbd_timer_DSR(cyg_vector_t vector, cyg_ucount32 count, cyg_addrword_t data);

static cyg_uint32
avr32_matrix_kbd_pin_ISR(cyg_vector_t vector, cyg_addrword_t data);

static void
avr32_matrix_kbd_pin_DSR(cyg_vector_t vector, cyg_ucount32 count, cyg_addrword_t data);
// Functions in this module

void matrix_disable()
{
	cyg_kbd_avr32.enabled = false;	
}

void matrix_enable()
{
	cyg_kbd_avr32.enabled = true;
}

/** Function to convert scan code to linux keyboard key mapping.
*
* \param scan_code is keyboard scan code.
* \return linux keyboard key code.
*/
static cyg_uint16 kbd_scan_code_to_key(cyg_uint32 scan_code)
{
	//diag_printf("Scan Code: 0x%X\n",scan_code);
	switch(scan_code)
	{
		case 0x10000:
		return K_ENTER;
		break;
		case 0x20000:
		return K_SAK;
		break;
		case 0x40000:
		return K_PGDN;
		break;
		case 0x04:
		return K_UP;
		break;
		case 0x008:
		return K_DOWN;
		break;
		/*case 0x0400:
		return K_F3;
		break;*/
		case 0x8000:
		return K_RIGHT;//'6';
		break;
		/*case 0x0020:
		return K_F3;//'5';*/
		break;
		case 0x0080:
		return K_LEFT;//'4';
		break;
		case 0x01:
		return K_F1;//'9';
		break;
		case 0x0002:
		return K_F2;//'7';
		break;
		case (0x008 | 0x0004):
		return K_F10;
		break;
		
		case 0x0800:
		return '0';
		break;
		case 0x00040:
		return '1';
		break;
		case 0x00400:
		return '2';
		break;
		case 0x4000:
		return '3';
		break;
		case 0x00020:
		return '4';
		break;
		case 0x00200:
		return '5';
		break;
		case 0x2000:
		return '6';
		break;
		case 0x00010:
		return '7';
		break;
		case 0x00100:
		return '8';
		break;
		case 0x1000:
		return '9';
		break;
	}
	
	return 0;
}

void matrix_keyboar_init()
{
    int i;
	cyg_kbd_avr32_t *kbd_dev = &cyg_kbd_avr32;
	// set first line to scan
    kbd_dev->scan_line          = 0;
    //
	while(AVR32_AST.sr & AVR32_AST_SR_BUSY_MASK)
	{
	}		
	// set pir interrupt interval = fc/2^(pir0 + 1)
    AVR32_AST.pir0 = CYGNUM_DEVS_KBD_MATRIX_SCAN_INTERVAL;
   
    // Configure GPIO pins used by keyboard
    gpio_configure_pin(AVR32_PIN_PA21, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
    gpio_configure_pin(AVR32_PIN_PA22, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
    gpio_configure_pin(AVR32_PIN_PA23, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
    gpio_configure_pin(AVR32_PIN_PA24, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
	gpio_configure_pin(AVR32_PIN_PA25, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
	
    gpio_configure_pin(AVR32_PIN_PA26, GPIO_DIR_INPUT );
    gpio_configure_pin(AVR32_PIN_PA27, GPIO_DIR_INPUT);
    gpio_configure_pin(AVR32_PIN_PA28, GPIO_DIR_INPUT);
    gpio_configure_pin(AVR32_PIN_PA29, GPIO_DIR_INPUT);
	
	// The keyboard rows are driving external interrupt controller
    gpio_enable_module_pin(AVR32_EIC_EXTINT_1_2_PIN, AVR32_EIC_EXTINT_1_2_FUNCTION);
    gpio_enable_module_pin(AVR32_EIC_EXTINT_2_PIN ,  AVR32_EIC_EXTINT_2_FUNCTION);
    gpio_enable_module_pin(AVR32_EIC_EXTINT_3_PIN,   AVR32_EIC_EXTINT_3_FUNCTION);
    gpio_enable_module_pin(AVR32_EIC_EXTINT_4_PIN,   AVR32_EIC_EXTINT_4_FUNCTION);
	 
	// Init keyboard timer interrupt 
    cyg_drv_interrupt_create(kbd_dev->interrupt_number,
                                 kbd_dev->interrupt_prio,                      // Priority
                                 (cyg_addrword_t)kbd_dev,   // Data item passed to interrupt handler
                                 avr32_matrix_kbd_timer_ISR,
                                 avr32_matrix_kbd_timer_DSR,
                                 &kbd_dev->kbd_interrupt_handle,
                                 &kbd_dev->kbd_interrupt);
    cyg_drv_interrupt_attach(kbd_dev->kbd_interrupt_handle);
	
	// Init keyboard rows interrupt
	for(i = 0; i < CYGNUM_DEVS_KBD_MATRIX_ISR_PINS; i++)
	{
		cyg_drv_interrupt_create(kbd_dev->kb_pins_isr[i].kbd_pin_interrupt_number,
				kbd_dev->interrupt_prio,                      // Priority
				(cyg_addrword_t)kbd_dev,   // Data item passed to interrupt handler
				avr32_matrix_kbd_pin_ISR,
				avr32_matrix_kbd_pin_DSR,
				&kbd_dev->kb_pins_isr[i].kbd_pin_interrupt_handle,
				&kbd_dev->kb_pins_isr[i].kbd_pin_interrupt);
		cyg_drv_interrupt_attach(kbd_dev->kb_pins_isr[i].kbd_pin_interrupt_handle);
	}
	
	//Configure pin interupt
	AVR32_EIC.mode &= ~(AVR32_EIC_MODE_INT4_MASK | AVR32_EIC_MODE_INT3_MASK |
						AVR32_EIC_MODE_INT2_MASK | AVR32_EIC_MODE_INT1_MASK);
	//spadovou
	AVR32_EIC.edge |= (AVR32_EIC_EDGE_INT4_MASK  | AVR32_EIC_EDGE_INT3_MASK	|
					   AVR32_EIC_EDGE_INT2_MASK  | AVR32_EIC_EDGE_INT1_MASK);
						
	AVR32_EIC.en   = AVR32_EIC_EN_INT4_MASK	     | AVR32_EIC_EN_INT3_MASK	|
	                 AVR32_EIC_EN_INT2_MASK      | AVR32_EIC_EN_INT1_MASK;
					  
	AVR32_EIC.icr = AVR32_EIC_ICR_INT4_MASK | AVR32_EIC_ICR_INT3_MASK |
				    AVR32_EIC_ICR_INT2_MASK | AVR32_EIC_ICR_INT1_MASK;
					
	AVR32_EIC.ier = AVR32_EIC_IER_INT4_MASK | AVR32_EIC_IER_INT3_MASK |
	                AVR32_EIC_IER_INT2_MASK | AVR32_EIC_IER_INT1_MASK;
	
}

/** Start keyboard scan timer.
*
* The pir0 interrupt is used to driver columns/lines scanning.
* \param kdb_dev is pointer to keyboard data structure.
*/
static void avr32_matrix_kbd_start_scan(cyg_kbd_avr32_t *kbd_dev)
{
	kbd_dev->push_cnt   = 0;
    kbd_dev->scan_line  = 0;
    AVR32_AST.ier       = AVR32_AST_IER_PER0_MASK;
}

/** Stop keyboard columns/lines scanning.
*
* The pir0 interrupt is used to driver columns/lines scanning.
* \param kdb_dev is pointer to keyboard data structure.
*/
static void avr32_matrix_kbd_stop_scan(cyg_kbd_avr32_t *kbd_dev)
{
    kbd_dev->scan_line  = 0;
    AVR32_AST.idr       = AVR32_AST_IDR_PER0_MASK;
}

/** Keyboard timer interrupt.
*
* The pir0 interrupt is handled in this function.
* In this function the rows scanning based on current
* line selection and next line selection is handled hear.
* \param vector is interrupt vector.
* \param data is pointer to driver data structure.
* \return value indicating to OS that DSR nead to be called.
*/
static cyg_uint32
avr32_matrix_kbd_timer_ISR(cyg_vector_t vector, cyg_addrword_t data)
{
    cyg_kbd_avr32_t *kbd_dev = (cyg_kbd_avr32_t*)data;
    cyg_uint32           ret = CYG_ISR_HANDLED;
    
	// is pir0 interrupt
    if(AVR32_AST.sr&AVR32_AST_SR_PER0_MASK)
    {
		// Clear pir0 interupt
		while(AVR32_AST.sr & AVR32_AST_SR_BUSY_MASK)
		{
		}
        AVR32_AST.scr  = AVR32_AST_SCR_PER0_MASK;
        
        if(kbd_dev->scan_line == 0)
        {
			// If scan line is zero set line to scan
            gpio_set_pin_high(AVR32_PIN_PA21);
            gpio_set_pin_low(AVR32_PIN_PA22);
            gpio_set_pin_low(AVR32_PIN_PA23);
            gpio_set_pin_low(AVR32_PIN_PA24);
			gpio_set_pin_low(AVR32_PIN_PA25);
            ++kbd_dev->scan_line;
			kbd_dev->scan_code = 0;
        }
        else if(kbd_dev->scan_line == 1)
        {
			// If scan line is non zero scan 
			// for active rows and update scan code
            if(gpio_get_pin_value(AVR32_PIN_PA26))
            {
				kbd_dev->scan_code |= 0x0001;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA27))
            {
                kbd_dev->scan_code |= 0x0002;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA28))
            {
                kbd_dev->scan_code |= 0x0004;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA29))
            {
                kbd_dev->scan_code |= 0x0008;
            }
			// Set next line to scan
            gpio_set_pin_low(AVR32_PIN_PA21);
            gpio_set_pin_high(AVR32_PIN_PA22);
            gpio_set_pin_low(AVR32_PIN_PA23);
            gpio_set_pin_low(AVR32_PIN_PA24);
			gpio_set_pin_low(AVR32_PIN_PA25);
            
            
            ++kbd_dev->scan_line;
        }
        else if(kbd_dev->scan_line == 2)
        {
            if(gpio_get_pin_value(AVR32_PIN_PA26))
            {
                 kbd_dev->scan_code |= 0x0010;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA27))
            {
                 kbd_dev->scan_code |= 0x0020;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA28))
            {
                 kbd_dev->scan_code |= 0x0040;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA29))
            {
                 kbd_dev->scan_code |= 0x0080;
            }

            gpio_set_pin_low(AVR32_PIN_PA21);
            gpio_set_pin_low(AVR32_PIN_PA22);
            gpio_set_pin_high(AVR32_PIN_PA23);
            gpio_set_pin_low(AVR32_PIN_PA24);
			gpio_set_pin_low(AVR32_PIN_PA25);
            
            
            ++kbd_dev->scan_line;
        }
        else if(kbd_dev->scan_line == 3)
        {
            if(gpio_get_pin_value(AVR32_PIN_PA26))
            {
                kbd_dev->scan_code |=  0x0100;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA27))
            {
                kbd_dev->scan_code |= 0x0200;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA28))
            {
                kbd_dev->scan_code |= 0x0400;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA29))
            {
                kbd_dev->scan_code |= 0x0800;
            }

            gpio_set_pin_low(AVR32_PIN_PA21);
            gpio_set_pin_low(AVR32_PIN_PA22);
            gpio_set_pin_low(AVR32_PIN_PA23);
            gpio_set_pin_high(AVR32_PIN_PA24);
			gpio_set_pin_low(AVR32_PIN_PA25);
            
            
            ++kbd_dev->scan_line;
        }
		else if(kbd_dev->scan_line == 4)
		{
			if(gpio_get_pin_value(AVR32_PIN_PA26))
			{
				kbd_dev->scan_code |=  0x1000;
			}
			if(gpio_get_pin_value(AVR32_PIN_PA27))
			{
				kbd_dev->scan_code |= 0x2000;
			}
			if(gpio_get_pin_value(AVR32_PIN_PA28))
			{
				kbd_dev->scan_code |= 0x4000;
			}
			if(gpio_get_pin_value(AVR32_PIN_PA29))
			{
				kbd_dev->scan_code |= 0x8000;
			}

			gpio_set_pin_low(AVR32_PIN_PA21);
			gpio_set_pin_low(AVR32_PIN_PA22);
			gpio_set_pin_low(AVR32_PIN_PA23);
			gpio_set_pin_low(AVR32_PIN_PA24);
			gpio_set_pin_high(AVR32_PIN_PA25);
			
			
			++kbd_dev->scan_line;
		}
        else if(kbd_dev->scan_line == 5)
        {
            if(gpio_get_pin_value(AVR32_PIN_PA26))
            {
                kbd_dev->scan_code |= 0x10000;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA27))
            {
                kbd_dev->scan_code |= 0x20000;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA28))
            {
                kbd_dev->scan_code |= 0x40000;
            }
            if(gpio_get_pin_value(AVR32_PIN_PA29))
            {
               kbd_dev->scan_code |= 0x80000;
            }

			// All keyboard lines was scanned 
			// put all lines to inactive state
            gpio_set_pin_high(AVR32_PIN_PA21);
            gpio_set_pin_high(AVR32_PIN_PA22);
            gpio_set_pin_high(AVR32_PIN_PA23);
            gpio_set_pin_high(AVR32_PIN_PA24);
			gpio_set_pin_high(AVR32_PIN_PA25);
            // Disable scan timer interrupt and
			// indicate that DSR nead to be processed
            AVR32_AST.idr       = AVR32_AST_IDR_PER0_MASK;
            kbd_dev->scan_line	= 0;
			ret |= CYG_ISR_CALL_DSR;            
        }
        else
        {
            CYG_ASSERT(false,"Unexpected scan position");
        }
    }
    
    return ret;
}

void matrix_set_repeat_interval(cyg_uint32 repeat)
{
	cyg_kbd_avr32.repeat_interval = repeat;
}

void matrix_set_repeat_default()
{
	cyg_kbd_avr32.repeat_interval = 20;
}
/** Keyboard timer DSR.
*
* The DSR is called after complete keyboard scanning is done.
* The repeating scanning of the keyboard is handled hear and
* as well sending keyboard event to the application.
* \param vector is interrupt vector.
* \param count is ??
* \param data is pointer to driver data structure.
*/
static void       
avr32_matrix_kbd_timer_DSR(cyg_vector_t vector, cyg_ucount32 count, cyg_addrword_t data)
{
    cyg_kbd_avr32_t *kbd_dev = (cyg_kbd_avr32_t*)data;
    
	// If scan code is non zero do some stuff
	// This DSR is called every ca. 0.0390625s
    if(kbd_dev->scan_code != 0)
    {

		// If the repeat interval for pushed button is reached
		if(kbd_dev->push_cnt == 0)
		{
			// Convert scan code to linux keyboard code
			cyg_uint16 key = kbd_scan_code_to_key(kbd_dev->scan_code);
			// if latest key is different from current
			// use longer interval
			if(kbd_dev->scan_code != kbd_dev->last_scan_code)
			{
				kbd_dev->push_cnt = 25;
				if(kbd_dev->enabled)
				{
					if(key < 255)
						queue_put(WM_ON_CHAR,key,WM_KEY_DOWN);
					else
						queue_put(WM_ON_KEY,key,WM_KEY_DOWN); 
				}
			}
			else
			{
				// otherwise use default repeat interval
				kbd_dev->push_cnt = kbd_dev->repeat_interval;
				if(kbd_dev->enabled)
				{
					if(key < 255)
						queue_put(WM_ON_CHAR,key,WM_KEY_HOLD);
					else
						queue_put(WM_ON_KEY,key,WM_KEY_HOLD);
				}
			}
				
		}
		else
		{
			// Other wise count interval timer down
			// The keyboard is scanned as well maybe 
			// not so perfect??
			kbd_dev->push_cnt--;
		}
		
        // Enable timer interrupt
        AVR32_AST.ier           = AVR32_AST_IER_PER0_MASK;
    }
	else
	{
		// If scan code is zero enable row pins interrupt
		// timer interrupt was disabled in ISR
		kbd_dev->push_cnt = 0;
		
		AVR32_EIC.icr = AVR32_EIC_ICR_INT4_MASK | AVR32_EIC_ICR_INT3_MASK |
						AVR32_EIC_ICR_INT2_MASK | AVR32_EIC_ICR_INT1_MASK;
		
		AVR32_EIC.ier = AVR32_EIC_IER_INT4_MASK | AVR32_EIC_IER_INT3_MASK |
						AVR32_EIC_IER_INT2_MASK | AVR32_EIC_IER_INT1_MASK;
	}
	   			
	kbd_dev->last_scan_code = kbd_dev->scan_code; 
}

/** Row keyboards pins interrupt.
*
* If Row interrupt is detected the keyboard scanning
* timer is started to scan the keyboard. No DSR called.
* \param vector is interrupt vector.
* \param data is keyboard driver data structure pointer.
*/
cyg_uint32 avr32_matrix_kbd_pin_ISR(cyg_vector_t vector, cyg_addrword_t data)
{

	AVR32_EIC.icr = AVR32_EIC_ICR_INT4_MASK | AVR32_EIC_ICR_INT3_MASK |
					AVR32_EIC_ICR_INT2_MASK | AVR32_EIC_ICR_INT1_MASK;
	
	AVR32_EIC.idr = AVR32_EIC_IDR_INT4_MASK | AVR32_EIC_IDR_INT3_MASK |
					AVR32_EIC_IDR_INT2_MASK | AVR32_EIC_IDR_INT1_MASK;
	
    avr32_matrix_kbd_start_scan((cyg_kbd_avr32_t *)data);
	return CYG_ISR_HANDLED;
}

void avr32_matrix_kbd_pin_DSR(cyg_vector_t vector, cyg_ucount32 count, cyg_addrword_t data)
{
	
}




